#include "soc/ledc_struct.h"

#include "nes_apu.h"

inline uint8_t apu(uint16_t address, uint8_t data) {
    return nes_apu_command(address, data, true);
}

uint8_t main_theme_trg_timer[] =  { 0xAB, 0x00, 0x53, 0x00, 0x1D, 0x00, 0x3A, 0xAB, 0x00, 0xAB, 0x53, 0x00, 0x1D, 0x00, 0xAB, 0x00, 0x40, 0x00, 0xFE, 0x00, 0xD5, 0x00, 0xAB, 0x40, 0x00, 0x40, 0xFE, 0x00, 0xD5, 0x00, 0xC4, 0x00, 0xAB, 0x00, 0x53, 0x00, 0x1D, 0x00, 0x3A, 0xAB, 0x00, 0xAB, 0x53, 0x00, 0x1D, 0x00, 0xAB, 0x00, 0x40, 0x00, 0x7C, 0x00, 0xC4, 0x00, 0x40, 0x7C, 0x00, 0xC4, 0x3A, 0x00, 0xFC, 0x00, 0xC4, 0x00 };
uint8_t main_theme_trg_length[] = { 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0X01, 0x00, 0X01, 0x00, 0X00, 0x00, 0x00, 0x00, 0X01, 0x01, 0x00, 0x01, 0X00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00 };

uint8_t enemy_hit_sq1_timer[] =  {0x35, 0x43, 0x54, 0x6A, 0x6A, 0x86, 0xA9, 0xD5, 0xD5, 0x0D, 0x53, 0xAB, 0xAB, 0x1A, 0xA6, 0x57 };
uint8_t enemy_hit_sq1_length[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0X01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03 };

uint8_t water_splash_noise_period[] =  { 0x08, 0x05, 0x05, 0x0C, 0x0C };

uint8_t game_over_sq0_timer[]  = {0xD5, 0x00, 0x1D, 0x1D, 0x0D, 0x00, 0x53, 0x40, 0x1D, 0xFE, 0xE2, 0x00, 0xD5, 0x00, 0x00};
uint8_t game_over_sq0_length[] = {0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

uint8_t game_over_sq1_timer[]  = {0xAB, 0x00, 0x3A, 0x3A, 0x1A, 0x00, 0xA6, 0x80, 0x3A, 0xFC, 0xC4, 0x00, 0xAB, 0x00, 0x00};
uint8_t game_over_sq1_length[] = {0x01, 0x00, 0x02, 0x02, 0x02, 0x00, 0x02, 0x02, 0x02, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00};

uint8_t game_over_trg_timer[]  = {0xAB, 0x00, 0x53, 0x00, 0x3A, 0x00, 0x53, 0x00, 0xC4, 0x00, 0x7C, 0x00, 0xAB, 0x00, 0x00};
uint8_t game_over_trg_length[] = {0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00};


volatile uint32_t current_frame = 0;

void IRAM_ATTR on_frame() {
    current_frame++;
}    

void wait_frames(int count) {

    uint32_t target_frame = current_frame + count;
    while(current_frame < target_frame) {
        delay(1);
    }
}

void apu_clock_timer() {
    apu_clock(25);
    auto& reg = LEDC.channel_group[0].channel[0];
    reg.duty.duty = apu_sample();
    reg.conf0.sig_out_en = 1; // This is the output enable control bit for channel
    reg.conf1.duty_start = 1; // When duty_num duty_cycle and duty_scale has been configured. these register won't take effect until set duty_start. this bit is automatically cleared by hardware
    reg.conf0.clk_en = 1;
}


void setup() {
  // put your setup code here, to run once:
    ledcSetup(0,15600*8,8);
    ledcAttachPin(33, 0);
    // ledcAttach(PIN_AOUT, 124800,8);
    ledcWrite(0,0);

    hw_timer_t *timer = timerBegin(0, 3, true); 
    timerAlarmWrite(timer, 745, true); // ~1789773 / 50
    timerAlarmEnable(timer); // Enable the alarm
    timerAttachInterrupt(timer, &apu_clock_timer, false); // Attach the interrupt handling function

    timer = timerBegin(2, 2, true); 
    timerAlarmWrite(timer, 666667, true); // 60hz
    timerAlarmEnable(timer); // Enable the alarm
    timerAttachInterrupt(timer, &on_frame, false); // Attach the interrupt handling function

}



void loop() {

    apu(0x4015, 0x0F); // ApuStatus

    apu(0x4000, 0xCA); // Sq0Duty
    apu(0x4001, 0x00); // Sq0Sweep

    apu(0x4004, 0xC4); // Sq1Duty
    apu(0x4005, 0x00); // Sq1Sweep

    apu(0x4008, 0x20); // TrgLinear

    apu(0x400C, 0x00); // NoiseVolume
    apu(0x400E, 0x00); // NoisePeriod

    // main level theme
    for (int i = 0; i < 64; i++) {
        uint8_t timer = main_theme_trg_timer[i];
        if (timer) {
            apu(0x400A, main_theme_trg_timer[i]); 
            apu(0x400B, main_theme_trg_length[i] | 0x10); 
            apu(0x400F, 0x01); // NoiseLength 
        }
        wait_frames(10);
    }

    // jump sound
    apu(0x4005, 0xAC); // Sq1Sweep
    apu(0x4006, 0xAB); // Sq1Timer
    apu(0x4007, 0x21); // Sq1Length    
    wait_frames(15);

    apu(0x4006, 0x7C); // Sq1Timer
    apu(0x4007, 0x21); // Sq1Length    
    wait_frames(30);

    apu(0x4005, 0xB3); // Sq1Sweep
    apu(0x4006, 0x57); // Sq1Timer
    apu(0x4007, 0x23); // Sq1Length    
    wait_frames(30);


    // enemy hit 
    apu(0x4005, 0xB3); // Sq1Sweep

    for (int i = 0; i < 16; i++) {
        apu(0x4006, enemy_hit_sq1_timer[i]); 
        apu(0x4007, enemy_hit_sq1_length[i] | 0x20); 
        wait_frames(4);
    }

    wait_frames(10);

    apu(0x4005, 0x00); // Sq1Sweep

    // water splash 
    for (int i = 0; i < 5; i++) {
        apu(0x400C, 0x0A); // NoiseVolume 
        apu(0x400E, water_splash_noise_period[i]); 
        apu(0x400F, 0x40); // NoiseLength 
        wait_frames(4);
    }

    wait_frames(50);

    for (int i = 0; i < 15; i++) {
        if (game_over_sq0_timer[i] != 0) {
            apu(0x4002, game_over_sq0_timer[i]); 
            apu(0x4003, game_over_sq0_length[i] | 0x20); 
        }
        if (game_over_sq1_timer[i] != 0) {
            apu(0x4006, game_over_sq1_timer[i]); 
            apu(0x4007, game_over_sq1_length[i] | 0x20); 
        }
        if (game_over_trg_timer[i] != 0) {
            apu(0x400A, game_over_trg_timer[i]); 
            apu(0x400B, game_over_trg_length[i] | 0x10); 
            apu(0x400F, 0x01); // NoiseLength 
        }    
        wait_frames(10);
    }
    
}

